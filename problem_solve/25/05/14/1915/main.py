# https://www.acmicpc.net/problem/1915
# 문제
# n×m의 0, 1로 된 배열이 있다. 이 배열에서 1로 된 가장 큰 정사각형의 크기를 구하는 프로그램을 작성하시오.

# 0	1	0	0
# 0	1	1	1
# 1	1	1	0
# 0	0	1	0
# 위와 같은 예제에서는 가운데의 2×2 배열이 가장 큰 정사각형이다.

# 입력
# 첫째 줄에 n, m(1 ≤ n, m ≤ 1,000)이 주어진다. 다음 n개의 줄에는 m개의 숫자로 배열이 주어진다.

# 출력
# 첫째 줄에 가장 큰 정사각형의 넓이를 출력한다.

# 예제 입력 1 
# 4 4
# 0100
# 0111
# 1110
# 0010
# 예제 출력 1 
# 4

import sys
input = sys.stdin.readline

n, m = map(int, input().split())
arr = [list(map(int, input().strip())) for _ in range(n)]
dp = [[0] * m for _ in range(n)]

# dp[i][j]를 i,j를 오른쪽 아래 꼭짓점으로 하는 정사각형의 한 변의 길이로 정의한다.
for i in range(n):
  for j in range(m):
    # 왼쪽 첫번째 열과 위쪽 첫번째 행은 기본 배열과 같다.
    if i == 0 or j == 0:
      dp[i][j] = arr[i][j]
    # 나머지 경우는 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
    elif arr[i][j] == 1:
      dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
    # 이미 0으로 초기화 되어 있으므로 생략 가능
    # else:
    #   dp[i][j] = 0

# dp[i][j]의 최대값을 구한다.
max_square = 0
for i in range(n):
  for j in range(m):
    max_square = max(max_square, dp[i][j])
print(max_square ** 2)


# 이 문제는 주어진 n×m 이진 배열에서 1로 이루어진 가장 큰 정사각형의 넓이를 찾는 문제입니다. 동적 프로그래밍(Dynamic Programming)을 활용해 효율적으로 해결할 수 있습니다.

# 해결 방법
# DP 테이블 정의: dp[i][j]를 (i,j)를 오른쪽 아래 꼭짓점으로 하는 정사각형의 최대 변 길이로 정의합니다.

# 초기값 설정: 첫 번째 행과 열은 원본 배열 값으로 초기화합니다.

# 점화식 적용:

# 현재 값이 1인 경우 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1

# 현재 값이 0인 경우 정사각형을 형성할 수 없으므로 0 유지

# 동작 원리
# 입력 처리: 행렬 크기(n,m)와 이진 배열을 입력받습니다.

# DP 테이블 순회: 각 셀을 순회하면서 가능한 최대 정사각형 크기를 계산합니다.

# 최대값 갱신: 매 셀 계산 시 최대 정사각형 크기를 실시간으로 갱신합니다.

# 결과 출력: 최종적으로 가장 큰 정사각형의 넓이(변 길이의 제곱)를 출력합니다.

# 이 알고리즘은 시간 복잡도 O(nm)으로 주어진 문제 제약 조건(최대 1000×1000)에서 효율적으로 동작합니다. 각 셀을 한 번씩만 처리하기 때문에 대규모 입력에도 안정적으로 대처할 수 있습니다.