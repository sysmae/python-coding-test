# https://www.acmicpc.net/problem/10986
# 문제
# 수 N개 A1, A2, ..., AN이 주어진다. 이때, 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.

# 즉, Ai + ... + Aj (i ≤ j) 의 합이 M으로 나누어 떨어지는 (i, j) 쌍의 개수를 구해야 한다.

# 입력
# 첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 106, 2 ≤ M ≤ 103)

# 둘째 줄에 N개의 수 A1, A2, ..., AN이 주어진다. (0 ≤ Ai ≤ 109)

# 출력
# 첫째 줄에 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 출력한다.

# 예제 입력 1 
# 5 3
# 1 2 3 1 2
# 예제 출력 1 
# 7



import sys
input = sys.stdin.readline

# 백준 10986번: 나머지 합
# 연속된 부분 구간의 합이 M으로 나누어떨어지는 구간의 개수를 구하는 문제
# 핵심 아이디어: 누적합과 모듈러 연산의 성질 활용
# 구간 [i+1, j]의 합이 M의 배수 ⟺ S[j] % M == S[i] % M

# 입력 처리
n, m = map(int, input().split())    # n: 배열 크기, m: 나누는 수
A = list(map(int, input().split())) # 원본 배열

# 배열 초기화
S = [0] * n     # 누적합 배열 (모듈러 연산 적용)
C = [0] * m     # 각 나머지별 개수를 저장할 배열 (0 ~ m-1)
ans = 0         # 최종 답: 조건을 만족하는 구간의 개수

# 1단계: 누적합 배열 생성 (모듈러 연산 포함)
S[0] = A[0] % m  # 첫 번째 원소의 나머지

for i in range(1, n):
    # 누적합을 구하면서 동시에 M으로 나눈 나머지 저장
    # (이전 누적합 + 현재 원소) % M
    S[i] = (S[i-1] + A[i]) % m

# 2단계: 경우별 카운팅
for i in range(n):
    # 경우 1: 처음부터 i번째까지의 합이 M으로 나누어떨어지는 경우
    if S[i] == 0:
        ans += 1
    
    # 각 나머지값의 개수를 카운팅
    # 같은 나머지를 가진 인덱스들끼리 구간을 만들 수 있음
    C[S[i]] += 1

# 3단계: 조합 계산 (같은 나머지를 가진 인덱스들 중 2개 선택)
for i in range(m):
    if C[i] > 1:
        # nC2 = n * (n-1) / 2 공식 적용
        # 같은 나머지를 가진 C[i]개의 인덱스 중 2개를 선택하는 조합
        ans += (C[i] * (C[i] - 1)) // 2

# 결과 출력
print(ans)

"""
예제 실행 과정:
입력: n=5, m=3, A=[1, 2, 3, 1, 2]

1. 누적합 계산:
   - 원본 배열: [1, 2, 3, 1, 2]
   - 누적합: [1, 3, 6, 7, 9]
   - S 배열 (누적합 % 3): [1, 0, 0, 1, 0]

2. 카운팅:
   - S[i] == 0인 경우: 3개 (인덱스 1, 2, 4)
   - C 배열: C[0]=3, C[1]=2, C[2]=0

3. 조합 계산:
   - C[0]=3 → C(3,2) = 3개 구간
   - C[1]=2 → C(2,2) = 1개 구간
   - 총합: 3 + 3 + 1 = 7개

시간복잡도: O(N)
공간복잡도: O(N + M)
"""

# import sys
# input = sys.stdin.readline

# N,M = map(int, input().split())
# A =  list(map(int, input().split()))
# S = [0] *N
# S[0] = A[0] % M
# C = [0] * M
# ans = 0

# # 누적합 모듈러 연산한 배열 S생성
# for i in range(1,N):
#   S[i] = (S[i-1] + A[i]) % M

# # 누적합 배열에서 각 숫자가 몇개씩 있는지 카운트
# # 만약 0이라면 그 자체로 만족하니 채우고, 아닌경우 C[] 배열에 해당 인덱스 맞춰서 갯수 증가
# for i in range(N):
#   if S[i] == 0:
#     ans += 1

#   C[S[i]] += 1

# # C[] 배열 돌면서 각 인덱스 별로 조합 계산, nC2 = (n)(n-1) // 2  
# for i in range(M):
#   ans += (C[i] * (C[i]-1)) //2
# print(ans)